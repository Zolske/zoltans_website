<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="keywords" content="Django, Django Notes" />
    <meta name="description" content="Zoltan's notes to Django." />
    <link rel="stylesheet" href="../../css/notes_navBar.css">
    <link rel="icon" href="../../images/logo/favicon/python.ico">
    <meta>
    <title>Django</title>
</head>

<body>
    <main>
        <h1><img src="../../images/logo/64x64_icons/django64x64.png" alt="">django</h1>
        <p class="expText">
            Django is a free and open source framework for building web apps with Python. It is used for the "backend".
        </p>
        <!-- >>> Set Up /////////////////////////////////////////////////////////////////////////////////////////////// -->
        <h2>Set UP</h2>
        <!-- set up your virtual environment in python & activate it-->
        <details class="conBox">
            <summary>set up a virtual environment in python & activate it</summary>
            <ol>
                <li>create a virtual environment:<br>
                    <code>python -m venv .venv</code>
                    <details class="exaBox">
                        <summary>.venv</summary>
                        <ol>
                            <li>the dot <code>.</code> hides the folder</li>
                            <li><code>venv</code> is the name of the folder</li>
                            <li>it is convention to name the folder <code>.venv</code></li>
                        </ol>
                    </details>
                </li>
                <li>activate the virtual environment on the terminal:<br><code>.venv\Scripts\Activate</code><br>
                    <details class="exaBox">
                        <summary><b>NOTE:</b> windows may requirer setting an execution policy</summary>
                        <ol>
                            <li>create a virtual environment:<br>
                                <code>python -m venv .venv</code><br>and set execution policy with the command
                                :<br><code> Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope
                                    CurrentUser</code></li>
                            <li>activate the virtual environment:<br><code>.venv\Scripts\Activate.ps1</code></li>
                        </ol>
                    </details>
                </li>
                <li>deactivate the virtual environment on the terminal:<br><code>deactivate</code></li>
                <li>add the hidden folder of the virtual environment (<b>.venv/</b> <mark
                        title="is the name of the virtual environment, don't forget '/' otherwise the content of the folder is added">*</mark>)
                    to the <b>.gitignore</b> file</li>
                <li>create a <b>requirements.txt</b> file which contains the record of the required packages:<br>
                    <code> pip freeze > requirements.txt</code><br>
                    (<i>the command needs to be repeated after new packages have been added</i>)</li>
            </ol>
        </details>
        <!-- install Django & create a project -->
        <details class="conBox">
            <summary>install Django & create a project</summary>
            <ol>
                <li>install Django:<br><code>python -m pip install django</code></li>
                <li>create a Django project:<br><code>django-admin startproject <b>django_project</b> .</code>
                    <details class="exaBox">
                        <summary>django_project .</summary>
                        <ol>
                            <li><code>django_project</code> is the name of the Django project, can be any name but don't
                                use hyphen</li>
                            <li><code>.</code> the dot is optional, but it tells Django to create the project in the
                                current directory and <b>not</b> to create a folder with the same name first</li>
                        </ol>
                    </details><br>
                    <details class="exaBox">
                        <summary>project folder structure</summary>
                        ├── django_project <mark title="project folder">*</mark><br>
                        │&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ├── __init__.py <mark
                            title="empty file which indicates that the files in the folder are part of a Python package">*</mark><br>
                        │&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ├── asgi.py <mark
                            title="allows for an optional Asynchronous Server Gateway Interface to be run">*</mark><br>
                        │&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ├── settings.py <mark
                            title="controls our Django project's overall settings">*</mark><br>
                        │&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ├── urls.py <mark
                            title="tells Django which pages to build in response to a browser or URL request">*</mark><br>
                        │&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └── wsgi.py <mark
                            title="stands for Web Server Gateway Interface, which helps Django serve our web pages">*</mark><br>
                        ├── manage.py <mark title="is not part of django_project but is used to execute various Django
commands such as running the local web server or creating a new app">*</mark><br>
                        └── .venv/ <mark title="hidden folder which contains the virtual environment">*</mark><br>
                    </details>

                </li>
            </ol>
        </details>
        <!-- Create An App -->
        <details class="conBox">
            <summary>create an app & register it in project/settings.py</summary>
            <p class="expText">
                Django uses the concept of projects and apps to keep code clean and readable. A single top-level Django
                project can contain multiple apps. Each app controls an isolated piece of functionality.
            </p>
            <ol>
                <li>create a new app:<br><code>python manage.py startapp <b>APP_NAME</b></code>
                    <br>
                    <details class="exaBox">
                        <summary>app file structure</summary>
                        ├─ pages <mark title="app folder, in this example the apps name is 'pages'">*</mark><br>
                        │&nbsp;&nbsp;&nbsp;&nbsp; ├─ __init__.py <mark
                            title="empty file which indicates that the files in the folder are part of a Python package">*</mark><br>
                        │&nbsp;&nbsp;&nbsp;&nbsp; ├─ admin.py <mark
                            title="is a configuration file for the built-in Django Admin app">*</mark><br>
                        │&nbsp;&nbsp;&nbsp;&nbsp; ├─ apps.py <mark
                            title="is a configuration file for the app itself">*</mark><br>
                        │&nbsp;&nbsp;&nbsp;&nbsp; ├─ migrations <mark
                            title="keeps track of any changes to our models.py file so it stays in sync with our database">*</mark><br>
                        │&nbsp;&nbsp;&nbsp;&nbsp; │&nbsp;&nbsp;&nbsp;&nbsp;└─ __init__.py <mark
                            title="empty file which indicates that the files in the folder are part of a Python package">*</mark><br>
                        │&nbsp;&nbsp;&nbsp;&nbsp; ├─ models.py <mark
                            title="is where we define our database models which Django automatically translates into database tables">*</mark><br>
                        │&nbsp;&nbsp;&nbsp;&nbsp; ├─ tests.py <mark title="is for app-specific tests">*</mark><br>
                        │&nbsp;&nbsp;&nbsp;&nbsp; └─ views.py <mark
                            title="is where we handle the request/response logic for our web app">*</mark><br>
                    </details>
                </li>
                <li><b>NOTE:</b> every app needs to be registered otherwise Django does not know about it,<br>
                    <i>add following code:</i><br>
                    <code>'<b>app_name</b>.apps.<b>App_name</b>Config'</code><br><i>to the</i> <b>INSTALLED_APPS =
                        []</b> <i>list in the</i>
                    <b>PROJECT_FOLDER/settings.py</b><br>
                    <!-- command explanation and example  -->
                    <details class="exaBox">
                        <summary>command explanation with example</summary>
                        <p><code>"<b>pages</b>.apps.<b>Pages</b>Config"</code></p>
                        <ul>
                            <li><b>pages</b> is the name of the app in this example</li>
                            <li>the <b>apps.py</b> file and its content is generated by Django when the app is
                                created<br>
                                <pre class="tabCode">
from django.apps import AppConfig


class PagesConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'pages'</pre>
                            </li>
                        </ul>
                        <ol>
                            <li><code><b>pages</b></code><br>tells Django to "walk" into the 'pages' package
                                (<i>folder</i>) </li>
                            <li><code>.apps</code><br>"walk" into the file 'apps.py'</li>
                            <li><code><b>Pages</b>Config</code><br>call the function</li>
                        </ol>
                    </details>
                </li>
            </ol>
        </details>
        <!-- how to run Django's local web server -->
        <details class="conBox">
            <summary>how to run Django's local web server</summary>
            <ol>
                <li>start Django's local web server on port 8000 with the command "runserver" which is located in
                    "manage.py"<br><code>python manage.py runserver</code><br>
                    <details class="exaBox">
                        <summary>change port</summary>
                        <ol>
                            <li>append the port number to the command, e.g.: port 9000<br><code>python manage.py
                                    runserver 9000</code></li>
                        </ol>
                    </details>
                    <details class="exaBox">
                        <summary>warning messages</summary>
                        <ul>
                            <li>warnings about 18 "<b>unapplied migrations</b>" appear because the initial database has
                                not jet been "migrated"</li>
                            <li>to migrate exit the local server <code>Ctrl + c</code> and run the
                                command:<br><code>python manage.py migrate</code></li>
                            <li>Django has now created a SQLite database and migrated its built-in apps. This is
                                represented by the new file <b>db.sqlite3</b> which was created in our directory.</li>
                        </ul>

                    </details>
                </li>
                <li>click the link in the terminal output or follow the link <a href="http://127.0.0.1:8000/"
                        target="_blank">http://127.0.0.1:8000/</a></li>
                <li>stop the local server with the terminal short cut <code>Ctrl + c</code></li>
            </ol>
        </details>
        <!-- <<< Set Up /////////////////////////////////////////////////////////////////////////////////////////////// -->
        <!-- >>> HTTP Request/Response Cycle /////////////////////////////////////////////////////////////////////////////// -->
        <h2>HTTP Request/Response Cycle</h2>
        <p class="expText">Every time you visit a webpage an initial “request” is sent by the “client” and a “response”
            is sent back by a “server”. What a web framework like Django does is accept HTTP requests to a
            given URL and returns a HTTP response containing the information necessary to render a webpage.
        </p>
        <!-- Django's MVT pattern -->
        <details class="conBox">
            <summary>Django's <b>MVT</b> pattern</summary>
            <ul>
                <p class="listH">Django's <b>MVT</b> pattern:</p>
                <li><b><u>M</u>odel:</b> Manages data and core business logic</li>
                <li><b><u>V</u>iew:</b> Describes which data is sent to the user but not its presentation</li>
                <li><b><u>T</u>emplate:</b> Presents the data as HTML with optional CSS, JavaScript, and Static Assets
                </li>
                <li><b>URL Configuration:</b> Regular-expression components configured to a View</li>
            </ul>
            <ol>
                <p class="listH">HTTP Request > URL > View > Model & Template > HTTP Response</p>
                <li>When you type in a URL, Django checks if (in project/urls.py) it finds a matching URL pattern.</li>
                <li>The URL pattern is linked to a single view (contained in views.py) which combines the data from the
                    model (stored in models.py) and the styling from a template (any file ending in .html).</li>
                <li> The view then returns a HTTP response to the user.</li>
            </ol>
        </details>
        <!-- example of an "HTTP Request/Response Cycle" -->
        <details class="conBox">
            <summary>example of an "HTTP Request/Response Cycle"</summary>
            <p class="expText">In Django, four separate files aligning with this MVT pattern are required to power one
                single dynamic (aka linked to a database) webpage:</p>
            <ol>
                <li>urls.py</li>
                <li>views.py</li>
                <li>models.py</li>
                <li>template.html (any HTML file will do)</li>
            </ol>
            <p>However, to create a static webpage (not linked to a database) we can hardcode the data into a view so
                the model is not needed.</p>
            <p>The following steppes show what happen's when the user enters an request in the url. The yellow
                highlighted code mark's the code which need to be added or has additional explanation.</p>
            <hr>
            <ol>
                <div class="floRight">
                    <img width="300" src="../../images/notes/python/django/HTTP_request_response_cycle-addrees.svg"
                        alt="">
                    <li>user adds a "slug"<mark
                            title="is the part of a URL that identifies a particular page on a website in an easy-to-read form">*</mark>
                        to the url address<br><i>for example: /hello</i></li>
                </div>
                <hr>
                <div class="floRight">
                    <img width="150" src="../../images/notes/python/django/HTTP_request_response_cycle-config_urls.svg"
                        alt="">
                    <li>Django look <b>always first</b> in the <code>PROJECT_NAME/urls.py</code> for the matching path
                        in
                        <code>urlpatterns&nbsp;=&nbsp;[]</code><br><i>example: updated the project/urls.py with the
                            yellow marked code</i><br>
                        <div class="hiCode">
                            #...PROJECT_NAME/urls.py<br>
                            from django.contrib import admin<br>
                            from django.urls import path<mark title="add the include() function: from django.urls">,
                                include</mark><br>
                            <br>
                            urlpatterns = [<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;path('admin/', admin.site.urls),<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;<mark title="django looks for a matching path from top to bottom, in our example 'hello/' matches,
        the include function directs the search to the app 'pages' file 'urls.py'">path('hello/',
                                include('pages.urls'))</mark><br>
                            ]
                        </div>
                    </li>
                    <hr>
                    <div class="floRight">
                        <img width="200" src="../../images/notes/python/django/HTTP_request_response_cycle-app_urls.svg"
                            alt="">
                        <li>the search is redirected to the apps <code>urls.py</code> to match the rest of the requested
                            'url' with the path in
                            <code>urlpatterns&nbsp;=&nbsp;[]</code><br>
                            <b>NOTE:</b> urls.py needs to be manually created in the 'apps' directory<br><i>
                                example: create the file pages/urls.py with the following
                                code</i><br>
                            <div class="hiCode">
                                #...pages/urls.py<br>
                                from django.urls import path<br>
                                from <mark
                                    title="the 'dot' tells Django to look in the same directory and 'views' to look in the 'views.py'">.views</mark>
                                import <mark title="import the 'homePageView' function">homePageView</mark><br>
                                <br>
                                urlpatterns = [<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;<mark
                                    title="the search matches the empty string because 'hello' has been already found before">path(''</mark>,
                                <mark
                                    title="calls the 'homePageView' function which has been declared in 'views.py'">homePageView</mark>,
                                <mark title="the 'named URL pattern' is optional">name ='home'</mark>),<br>
                                ]<br>
                            </div>
                        </li>
                        <li>the '<b>homePageView</b>' function (FBVs) is called from the apps <code>views.py</code>
                            file<br><i>example: updated the pages/views.py with the
                                yellow marked code</i><br>
                            <div class="hiCode">
                                # pages/views.py<br>
                                <mark
                                    title="imports the build-in 'HttpResponse' method  so we can return a response object to the user">from
                                    django.http import HttpResponse</mark><br>
                                <br>
                                <br>
                                def homePageView<mark
                                    title="the function accepts the request object">(request)</mark>:<br>
                                <mark title="returns a response with the string 'Hello, World!'">return
                                    HttpResponse("Hello, World!")</mark><br>
                            </div>
                        </li>
                        <hr>
                        <div class="floRight">
                            <img width="300"
                                src="../../images/notes/python/django/Copy of HTTP_request_response_hello.svg" alt="">
                            <li>a page with the string "Hello, World!" is returned to the user</li>
                        </div>
                    </div>
                </div>
            </ol>
            <hr>
        </details>
        <!-- <<< HTTP Request/Response Cycle /////////////////////////////////////////////////////////////////////////////// -->
        <!-- connect a apps views -->
        <h2>connecting the apps "views"</h2>
        <details class="conBox">
            <summary>connecting the apps "views" (class-based generic views)</summary>
            <ol>
                <li>in "PROJECT_NAME/urls.py", add the "url path" to the urlpattern<br>
                    <div class="hiCode">
                        #...PROJECT_NAME/urls.py<br>
                        from django.contrib import admin<br>
                        from django.urls import path<mark title="add the include() function: from django.urls">,
                            include</mark><br>
                        <br>
                        urlpatterns = [<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;path('admin<mark
                            title="all paths need to have a backslash / if they are not empty">/</mark>',
                        admin.site.urls),<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<mark title="django looks for a matching path from top to bottom, a empty string as first parameter '' works as homepage
(no slug, just the default address), the 'include function' directs the search to the app named
'pages' and from there to the file 'urls.py'">path('',
                            include('pages.urls'))</mark><br>
                        ]
                    </div>
                </li>
                <li>create the "urls.py" file in the app<br>
                    <div class="hiCode">
                        #...pages/urls.py<br>
                        from django.urls import path<br>
                        from <mark
                            title="the 'dot' tells Django to look in the same directory and 'views' to look in the 'views.py'">.views</mark>
                        import HomePageView, AboutPageView<br>
                        <br>
                        urlpatterns = [<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;path("about<mark
                            title="all paths need to have a backslash / if they are not empty">/</mark>",
                        AboutPageView.as_view(), <mark
                            title="The 'url name' is optional, it is used by the 'url tag' to link to the page">name='about'</mark>),<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<mark title="the 1st parameter is a empty string">path(''</mark>,
                        <mark
                            title="name of the view needs to have the addition 'as_view()'">HomePageView.as_view()</mark>,
                        <mark
                            title="the 'named URL pattern' is optional, it is used by the 'url tag' to link to the page">name
                            ='home'</mark>),<br>
                        ]</div>
                    <ul>
                        <li>when using Class-Based Views, you always add <b>as_view()</b> to the end of the view name
                        </li>
                    </ul><br>
                    </div>
                </li>
                <li>write the logic for the "views" into the app's views.py<br>
                    <p class="hiCode"># pages/views.py<br>
                        from django.views.generic import TemplateView<br>
                        <br>
                        <br>
                        class HomePageView(TemplateView):<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;template_name = "home.html"
                        <br>
                        <br>
                        class AboutPageView(TemplateView):<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;template_name = "about.html"</p>
                    <details class="exaBox">
                        <summary>the built-in TemplateView</summary>
                        <ul>
                            <li>it is a <b>class-based generic views</b></li>
                            <li>Note that we've capitalized our view, HomePageView, since it's now a Python class.
                                Classes, unlike functions, should always be capitalized.</li>
                            <li> The TemplateView already contains all the logic needed to display our template, we just
                                need to specify the template's name.</li>
                        </ul>
                    </details>
                </li>
            </ol>
        </details>
        <!-- templates -->
        <h2>connecting the templates</h2>
        <p class="expText">Templates are individual HTML files that can be linked together and also include basic logic.
        </p>
        <details class="conBox">
            <summary>where to place templates</summary>
            <h3>django's default template structure</h3>
            <p>By default, Django's template loader will look within each app for related templates. However the
                structure is somewhat confusing: each app needs a new templates directory, another directory with the
                same name as the app, and then the template file.</p>
            <p>└─ pages <mark title="app folder">*</mark><br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;├─ templates <mark
                    title="folder needs to be manually created, django is looking for it when searching for templates">*</mark><br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;├─ pages <mark
                    title="the templates need to be saved in another folder with the same name as the app">*</mark><br>
                &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;├─ home.html <mark
                    title="the actually template HTML file ">*</mark></p>
            <h3>one level template file structure</h3>
            <ol>
                <li>create a folder called "<b>templates</b>" in the root directory, in which you will save your HTML
                    files<br>
                    <code>mkdir templates</code></li>
                <li> update "<b>django_project/settings.py</b>" to tell Django the location of our new templates
                    directory.<br>
                    <p class="hiCode">
                        # django_project/settings.py<br>
                        TEMPLATES = [<br>
                        &nbsp;&nbsp;{<br>
                        &nbsp;&nbsp;...<br>
                        &nbsp;&nbsp;"DIRS": [<mark title="add this code">BASE_DIR / "templates"</mark>],<br>
                        &nbsp;&nbsp;...<br>
                        &nbsp;&nbsp;},<br>
                        ]</p>
                </li>
            </ol>
            <p>├─ django_project <mark title="django project folder">*</mark><br>
                ├─ pages <mark title="app folder">*</mark><br>
                ├─ templates <mark title="folder needs to be manually created, django is looking for it when searching
for templates, it is not under the app folder but in the root directory">*</mark><br>
                &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; ├─ home.html <mark
                    title="the actually template HTML file ">*</mark></p>
        </details>
        <!-- extending templates -->
        <h2>extending templates</h2>
        <p class="expText">Content that is repeated on every page (header, footer, ...) can be inherited by all other
            templates. This is achieved with the help of Django's templating language.</p>
        <details class="conBox">
            <summary>adding links with Django's templating language</summary>
            <ol>
                <li>create the base template (<i>from which other templates will inherit</i>) which is called
                    "<b>base.html</b>" by convention and save it in the "<b>templates</b>" folder<br>
                    <p>
                        ├─ pages<br>
                        ├─ templates<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;├─ base.html <mark
                            title="'parent template' conventionally called 'base.html'">*</mark><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;├─ home.html<br>
                    </p>
                </li>
                <li>add following code to the the base.html:<br>
                    <p class="hiCode">
                        # ... templates/base.html<br>
                        &lt;header><br>
                        &nbsp;&nbsp;&lt;a href="{% url <mark title="the 'URL name' is created in the APP/urls.py,
The 'url tag' uses these names to automatically create a link">'home'</mark> %}">Home&lt;/a> |<br>
                        &nbsp;&nbsp;&lt;a href="<mark
                            title="link to the page">{% url 'about' %}</mark>">About&lt;/a><br>
                        &lt;/header><br>
                        <br>
                        {% block content %}<br>
                        {% endblock content %}</p>
                    <ul>
                        <li>Template tags take the form of <b>{% something %}</b> where the “something” is the template
                            tag itself.</li>
                        <li>full list of built-in template tags <a
                                href="https://docs.djangoproject.com/en/4.0/ref/templates/builtins/#built-in-template-tags-and-filters"
                                target="_blank">here in the official docs</a></li>
                        <li>To add URL links in our project we can use the built-in url template tag which takes the URL
                            pattern name as an argument. (<a
                                href="https://docs.djangoproject.com/en/4.0/ref/templates/builtins/#url"
                                target="_blank">link to official "url tag" docs</a>)</li>
                        <li>Blocks can be overwritten by child templates via inheritance. While it's optional to name
                            our closing endblock (<i>you could just write {% endblock %}</i>) doing so helps
                            with readability, especially in larger template files.</li>
                    </ul>
                </li>
                <li>update the 'child template' with the extend method (<i><a
                            href="https://docs.djangoproject.com/en/4.0/ref/templates/builtins/#extends"
                            target="_blank">link to official extend doc</a></i>)<br>
                    <p class="hiCode">
                        # ... templates/home.html<br>
                        <mark title="connection to the 'parent template'">{% extends "base.html" %}</mark><br>
                        <br>
                        <mark title="the content between this blocks is inserted into this version of the 'parent template',
all other elements are the same as in the 'parent'">{% block content %}</mark><br>
                        &lt;h1>Homepage&lt;/h1><br>
                        {% endblock content %}
                    </p>
                    <ul>
                        <li>the <b>{% extends "..." %}</b> block/method connects the 'child template' to the 'parent
                            template'</li>
                        <li>every element is taken from the 'parent' except the part with the <b>{% block content %}</b>
                            which is replaced with the 'child's' <b>{% block content %}</b> content</li>
                    </ul>
                </li>
            </ol>
        </details>
        <!-- tests -->
        <h2>tests</h2>
        <p class="expText">
            It's important to add automated tests and run them whenever a codebase changes. Tests require a small amount
            of upfront time to write but more than pay off later on.
        </p>
        <!-- testing -->
        <details class="conBox">
            <summary>testing</summary>
            <p class="listH">there are two types of tests ...</p>
            <ol>
                <li><b>Unit tests:</b><br>check a piece of functionality in isolation <ul>
                        <li class="thumbUp">run faster and are easier to maintain since they focus on only a small piece
                            of code</li>
                    </ul>
                </li>
                <li><b>Integration tests:</b><br>check multiple pieces linked together <ul>
                        <li class="thumbDown"> are slower and harder to maintain since a failure doesn't point you in
                            the specific
                            direction of the cause</li>
                    </ul>
                </li>
            </ol>
            <ul>
                <li>Most developers focus on writing many unit tests and a small amount of integration tests.</li>
                <li>Django's own testing framework provides several extensions on top of Python's <b>unittest</b>.</li>
            </ul>
            <p class="listH">Django tests ...</p>
            <ul>
                <li><a href="https://docs.djangoproject.com/en/4.0/topics/testing/tools/#the-test-client"
                        target="_blank">test client</a> for making dummy Web browser requests,</li>
                <li>a number of Django-specific additional <a
                        href="https://docs.djangoproject.com/en/4.0/topics/testing/tools/#assertions"
                        target="_blank">assertions</a>,</li>
                <li>
                    <p class="listH">Django has four test case classes: ...</p>
                    <ul>
                        <li><b>SimpleTestCase:</b> (<i><a
                                    href="https://docs.djangoproject.com/en/4.0/topics/testing/tools/#simpletestcase"
                                    target="_blank">official doc</a></i>)<br>is used when a database is not necessary
                        </li>
                        <li><b>TestCase:</b> (<i><a
                                    href="https://docs.djangoproject.com/en/4.0/topics/testing/tools/#testcase"
                                    target="_blank">official doc</a></i>)<br> is used when you do want to test the
                            database</li>
                        <li><b>TransactionTestCase:</b> (<i><a
                                    href="https://docs.djangoproject.com/en/4.0/topics/testing/tools/#transactiontestcase"
                                    target="_blank">official doc</a></i>)<br>useful if you need to directly test
                            database transactions</li>
                        <li><b>LiveServerTestCase:</b> (<i><a
                                    href="https://docs.djangoproject.com/en/4.0/topics/testing/tools/#django.test.LiveServerTestCase"
                                    target="_blank">official doc</a></i>)<br>launches a live server thread useful for
                            testing with browser-based tools like "Selenium"</li>
                    </ul>
                    <details class="exaBox">
                        <summary>naming of methods in unittest and django.test</summary>
                        <p>The naming of methods in unittest and django.test are written in camelCase rather than the
                            more Pythonic snake_case pattern. The reason is that unittest is based on the jUnit testing
                            framework from Java, which does use camelCase, so when unittest was added to Python it came
                            along with camelCase naming.</p>
                    </details>
                    <p>Tests are written in the apps <b>test.py</b> and executed in the terminal.<br><code>python
                            manage.py test</code>
                    </p>
                </li>
            </ul>
        </details>
        <!-- testing with 'SimpleTestCase' -->
        <details class="conBox">
            <summary>testing with 'SimpleTestCase'</summary>
            <p class="expText">Generally it is a good idea to abide by the concept of DRY (Don't Repeat Yourself)
                coding, but unit tests work best when they are self contained and extremely verbose.</p>
            <p class="listH">test to check if HTTP status codes of 200 is returned</p>
            <ol>
                <li>write the test in the apps test.py<br>
                    <p class="hiCode">
                        # pages/tests.py<br>
                        from django.test import SimpleTestCase<br>
                        <br>
                        <br>
                        class HomepageTests(SimpleTestCase):<br>
                        &nbsp;&nbsp;def test_url_exists_at_correct_location(self):<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;response = self.client.get("/")<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(response.status_code, 200)<br>
                        <br>
                        <br>
                        class AboutpageTests(SimpleTestCase):<br>
                        &nbsp;&nbsp;def test_url_exists_at_correct_location(self):<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;response = self.client.get("/about/")<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(response.status_code, 200)</p>
                </li>
            </ol>
            <p class="listH">test if the 'url name' matches the 'url path'</p>
            <ol>
                <li>Django utility function <a href="https://docs.djangoproject.com/en/4.0/ref/urlresolvers/#reverse"
                        target="_blank">reverse</a> can be used for testing<br>
                    <p class="hiCode">
                        # pages/tests.py<br>
                        from django.urls import reverse<br>
                        <br>
                        <br>
                        class HomepageTests(SimpleTestCase):<br>
                        &nbsp;&nbsp;def test_url_available_by_name(self):<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;response = self.client.get(reverse("home"))<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(response.status_code, 200)<br>
                        <br>
                        <br>
                        class AboutpageTests(SimpleTestCase):<br>
                        &nbsp;&nbsp;def test_url_available_by_name(self):<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;response = self.client.get(reverse("about"))<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;self.assertEqual(response.status_code, 200)</p>
                </li>
            </ol>
            <p class="listH">correct templates and that they display the expected content</p>
            <ol>
                <li>We can use <a
                        href="https://docs.djangoproject.com/en/4.0/topics/testing/tools/#django.test.SimpleTestCase.assertTemplateUsed"
                        target="_blank">assertTemplateUsed</a> and <a
                        href="https://docs.djangoproject.com/en/4.0/topics/testing/tools/#django.test.SimpleTestCase.assertContains"
                        target="_blank">assertContains</a> to achieve this.<br>
                    <p class="hiCode">
                        # pages/tests.py<br>
                        from django.test import SimpleTestCase<br>
                        from django.urls import reverse<br>
                        <br>
                        <br>
                        class HomepageTests(SimpleTestCase):<br>
                        &nbsp;&nbsp;def test_template_name_correct(self):<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;response = self.client.get(reverse("home"))<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;self.assertTemplateUsed(response, "home.html")<br>
                        <br>
                        &nbsp;&nbsp;def test_template_content(self):<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;response = self.client.get(reverse("home"))<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;self.assertContains(response, "&lt;h1>Homepage&lt;/h1>")<br>
                        <br>
                        <br>
                        class AboutpageTests(SimpleTestCase):<br>
                        &nbsp;&nbsp;def test_template_name_correct(self):<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;response = self.client.get(reverse("about"))<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;self.assertTemplateUsed(response, "about.html")<br>
                        <br>
                        &nbsp;&nbsp;def test_template_content(self):<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;response = self.client.get(reverse("about"))<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;self.assertContains(response, "&lt;h1>About page&lt;/h1>")</p>
                </li>
            </ol>
        </details>
        <!-- Local vs Production -->
        <h2>Local vs Production</h2>
        <p class="expText">To make our site available on the Internet where everyone can see it, we need to deploy our
            code to an external server and database. This is called putting our code into <b>production</b>.<br>Django
            comes with its own basic server, which is only suitable for local usage.<br>
            As web server we can use <a href="https://gunicorn.org/" target="_blank">Gunicorn</a> and as hosting
            provider <a href="https://www.heroku.com/home" target="_blank">Heroku</a>.</p>
        <!-- deployment checklist -->
        <details class="conBox">
            <summary>deployment checklist</summary>
            <ol>
                <li>install Gunicorn<br><code>python -m pip install gunicorn</code></li>
                <li>create a requirements.txt file <details class="exaBox">
                        <summary>explanation</summary>
                        <p>Create a requirements.txt file containing all the specific Python dependencies in our
                            project. That is, every Python package currently installed in our virtual environment. This
                            is necessary in case we (or a team member) want to recreate the repository from scratch in
                            the future. It also helps Heroku recognize that this is a Python project, which simplifies
                            the deployment steps.</p>
                    </details><br><code>python -m pip freeze > requirements.txt</code></li>
                <li>update <a href="https://docs.djangoproject.com/en/4.0/ref/settings/#allowed-hosts"
                        target="_blank">ALLOWED_HOSTS</a> in django_project/settings.py <details class="exaBox">
                        <summary>explain ALLOWED_HOSTS</summary>
                        <p>The ALLOWED_HOSTS setting represents that host/domain names our Django site can serve.
                            This is a security measure to prevent HTTP Host header attacks. For now, we'll use the
                            wildcard asterisk, * so that all domains are acceptable.</p>
                    </details><br>
                    <code>
                        ALLOWED_HOSTS = ["<mark title="the wildcard asterisk *, all domains are acceptable">*</mark>"]
                    </code>
                </li>
                <li>create a file named "<b>Procfile</b>" with no extension in the root directory with following
                    code:<br>
                    <code>web: gunicorn django_project.wsgi --log-file -</code><br>
                    (<i>The Procfile is specific to Heroku and provides instructions on how to run the application in
                        their stack.</i>) <ul>
                        <li><b>web: gunicorn</b><br>
                            for the web function to use gunicorn as the server</li>
                        <li><b>django_project.wsgi</b><br>
                            to use the WSGI config file located at <mark
                                title="Django project folder">django_project</mark>.wsgi</li>
                        <li><b>--log-file -</b><br>
                            the flag --log-file - makes any logging messages visible to us</li>
                    </ul>
                </li>
                <li>create a file named "<b>runtime.txt</b>" in the root directory and add which Python version should
                    run on Heroku (<i><a href="https://devcenter.heroku.com/articles/python-runtimes"
                            target="_blank">doc 'runtime.txt'</a></i>)<br>
                    <code>python-3.10.2</code>
                    <ul>
                        <li>you can check the used python version with the command:<br>
                            <code>python --version</code></li>
                    </ul>
                </li>
            </ol>
        </details>
        <h2>deploying an app to Heroku over the cli</h2>
        <details class="conBox">
            <summary>how to deploy to Heroku</summary>
            <ol>
                <li>execute the "deployment checklist"</li>
                <li>ignore static files (like CSS & JavaScript) for now<br>
                    <code>heroku config:set DISABLE_COLLECTSTATIC=1</code></li>
                <li>push the code to Heroku<br><code>git push heroku main</code></li>
                <li>make the Heroku app "live"<br>
                    <code>heroku ps:scale web=1</code></li>
                <li>opens the "web browser" with the "life" version of our Heroku app<br>
                    <code>heroku open</code></li>
            </ol>
        </details>
        <h2>Django's ORM (<u>O</u>bject-<u>R</u>elational <u>M</u>apper)</h2>
        <p class="expText">
            There is built-in support for multiple database backends: PostgreSQL, MySQL, MariaDB, Oracle, and SQLite.
            This means that we, as developers, can write the same Python code in a models.py file and it will
            automatically be translated into the correct SQL for each database. The only configuration required is to
            update the <a href="https://docs.djangoproject.com/en/4.0/ref/databases/" target="_blank">DATABASES</a>
            section of our django_project/settings.py file.
        </p>
        <!-- creating a database -->
        <details class="conBox">
            <summary>creating a database</summary>
            <ul>
                <li>execute the migrate command to create an initial database based on Django's default settings<br>
                    <code>python manage.py migrate</code><br>
                    <details class="exaBox">
                        <summary>migrate</summary>
                        <p> Migrate will sync the database with the current state of any database models contained in
                            the project and listed in INSTALLED_APPS. In other words, to make sure the database reflects
                            the current state of your project you'll need to run migrate (and also makemigrations) each
                            time you update a model.</p>
                    </details>
                </li>
            </ul>
        </details>
        <!-- Create a Database Model -->
        <details class="conBox">
            <summary>Create a Database Model</summary>
            <p class="expText">Django's ORM will automatically turn this model into a database table for us.</p>
            <ul>
                <li>Create a new database model in the <b>models.py</b> which is called Post and has the database field
                    text.<br>
                    <p class="hiCode">
                        # posts/models.py<br>
                        from django.db import models<br>
                        <br>
                        <br>
                        class <mark title="name of the new database model is 'Post'">Post</mark>(models.Model):<br>
                        &nbsp;&nbsp;text = models.<mark
                            title="specified the type of content it will hold, TextField()">TextField()</mark></p>
                </li>
                <li>Django provides many <a href="https://docs.djangoproject.com/en/4.0/ref/models/fields/"
                        target="_blank">model fields</a> supporting common types of content such as characters, dates,
                    integers, emails, and so on.</li>
            </ul>
        </details>
        <!-- Activating models -->
        <details class="conBox" open>
            <summary>Activating models</summary>
            <p class="expText">After a new model is created, it need's to be also activate.</p>
            <ul>
                <li>Whenever we create or modify an existing model we will need to update Django in a two-step process:
                    <ol>
                        <li>create a migrations file with the makemigrations command<br>
                            <code>python manage.py makemigrations DATABASE_NAME</code>
                            <br>
                            <ul>
                                <li>Migration files create a reference of any changes to the database models which means
                                    we can track changes and debug errors as necessary over time.<br>
                                    <details class="exaBox">
                                        <summary>migrations for all</summary>
                                        <p>Note that you don't have to include a name after makemigrations. If you
                                            simply run python manage.py makemigrations, a migrations file will be
                                            created for all available changes throughout the Django project. That is
                                            fine in a small project such as ours with only a single app, but most Django
                                            projects have more than one app! Therefore ,if you made model changes in
                                            multiple apps the resulting migrations file would include all those changes!
                                            This is not ideal. Migrations file should be as small and concise as
                                            possible as this makes it easier to debug in the future or even roll back
                                            changes as needed. Therefore, as a best practice, adopt the habit of always
                                            including the name of an app when executing the makemigrations command!</p>
                                    </details>
                                </li>
                            </ul>
                        </li>
                        <li>we build the actual database with the migrate command which executes the instructions in our
                            migrations file.<br>
                            <code>python manage.py migrate</code></li>
                    </ol>
                </li>
            </ul>
        </details>
    </main>
    <script src="../../js/add_navBarPython.js"></script>
</body>

</html>